# 2개 이하로 다른 비트

## 문제 설명

양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

    수	비트	다른 비트의 개수
    2	000...0010
    3	000...0011	1

f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

    수	비트	다른 비트의 개수
    7	000...0111
    8	000...1000	4
    9	000...1001	3
    10	000...1010	3
    11	000...1011	2

정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

## 제한 조건

- 1 ≤ numbers의 길이 ≤ 100,000
- 0 ≤ numbers의 모든 수 ≤ 1015

### 의사코드

1. 십진수 x가 짝수라면 이진수로 변경했을 때 0으로 끝나므로, 맨 마지막 0을 1로 바꿔준다. 그러므로 주어진 수 x+1이 정답이다.

2. 십진수 x가 홀수라면, x를 이진수로 바꾸고 맨 뒤에서부터 가장 처음으로 나오는 0을 찾아주고,
   0의 바로 전 자리에서 1을 더해준다 생각하면, 0을 1로 바꾸고 바로 전 자리의 1을 0으로 바꿔준다.

### Point

- 이 문제는 2가지 조건으로 나누어서 풀면 되는 문제이다.
- 맨 뒤 비트가 0일 때 이 경우 단순히 맨 뒤 비트를 1로 바꿔주면 해당 수보다 큰 수 중 가장 작은 값이 된다.
- 맨 뒤 비트가 0이 아닐 때
  이 경우, 뒤에서 부터 첫번째로 등장하는 "01"을 찾는다. 그리고 이 부분을 "10"으로 바꿔주면 2비트만 바꾸어 만들 수 있는 가장 작은 값이 된다.

#### Code

```js
function solution(numbers) {
  function f(num) {
    if (num % 2 === 0) return num + 1;

    const bit = "0" + num.toString(2);
    const index = bit.lastIndexOf("0");
    return parseInt(`${bit.slice(0, index)}10${bit.slice(index + 2)}`, 2);
  }
  return numbers.map((ele) => f(ele));
}
```
