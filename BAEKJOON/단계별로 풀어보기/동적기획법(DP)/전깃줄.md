# 전깃줄 (2565번) [node.js, JavaScript] 

## 문제 설명
[전깃줄 문제 설명](https://www.acmicpc.net/problem/2565)

## 입력
첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100 이하의 자연수이다. 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.

## 출력
첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.

### 문제설명 
- 11053번 가장 긴 증가하는 부분 수열(LIS)를 구하는 문제와 유사합니다.
1. A번 숫자를 기준으로 오름차순 정렬합니다. 그러면 B전봇대 숫자들의 나열된 숫자는 (예제입력1) 8, 2, 9, 1, 4, 6, 7, 10이 됩니다.
2. 이 숫자들을 기준으로 증가하는 부분 수열의 길이 구한 값이 서로 교차하지 않게 연결된 전깃줄의 개수가 되므로 총 연결된 개수 N에서 빼면 없애야하는 전깃줄의 개수를 구하게됩니다.

### 의사코드 
1. 입력값을 오름차순으로 정렬된 배열로 만들어줍니다. 
2. 현재 요소를 기준으로 앞에있는 요소 모두 비교합니다. 현재 요소가 앞에있는 요소보다 값이 크면 앞에 요소의 수열 길이를 cnt변수에 저장해줍니다. 작다면 전깃줄이 교차되므로 넘어갑니다.
3. 현재 요소와 앞전에 있던 요소 비교가 모두 끝나면 cnt 변수에 저장된 증가하는 부분 수열의 길이cnt를 DP 배열에 더해줍니다.
4. 모든 반복문이 끝나고 나면 DP에는 입력값들의 증가하는 부분 수열의 길이가 저장되어있습니다. DP 요소에서 가장 큰값을 추출한 후 N값에서 빼주면 없애야하는 개수가 출력됩니다.

### Code
```js
const input = require("fs").readFileSync("/dev/stdin").toString().trim().split("\n"); 

const N = +input.shift();
const numbers = input.map(e => e.split(' ').map(Number)).sort((a, b) => a[0] - b[0]);
const dp = Array.from({ length: N }, () => 1);

for (let i = 1; i < N; i++) { // A 1부터 10까지 순회하는 반복문
    let cnt = 0;
    const currentElement = numbers[i][1];

  for (let j = 0; j < i; j++) { // A 비교 지점부터 10까지 순회하는 반복문
        if (currentElement > numbers[j][1]) {
        cnt = Math.max(cnt, dp[j]);
        }
    }
        dp[i] += cnt;
}

console.log(N - Math.max(...dp));
```
