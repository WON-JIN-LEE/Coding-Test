# 평벙한 배낭 (12865번) [node.js, JavaScript] 

## 문제 설명
이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

## 입력
첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

## 출력
한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

### 의사코드 
1. 물건의 개수 len,  준서가 버틸 수 있는 무게 max로 받는다.
2. dp[j]는 j무게를 가져간다고 했을때 가치의 최대합이 저장된다.
3. 물품의 개수만큼 반복문을 실행합니다. i는 물품의 무게와 가치의 인덱스입니다. j는 준수가 버틸 수 있는 무게를 의미합니다. 
4. max 무게보다는 작아야한다. 그러므로 j-W[i] 값이 0보다 크거나 같아야한다.
5. 위 조건을 만족한다면 j무게일때 현재 저장되어있는 j무게가치의 최대값 dp[j]와 dp[j-W[i]] + V[i] 둘 중에 최대값을 dp[j]에 갱신하면 dp[max]에는 가치의 최대값이 저장됩니다.

### Code
```js
const input = require("fs").readFileSync("/dev/stdin").toString().split("\n");

const [len, max] = input[0].split(" ").map(Number);

const W = new Array(len + 1); // 무게
const V = new Array(len + 1); // 가치
const dp = new Array(max + 1).fill(0);

for (let i = 1; i <= len; i++) {
  const [w, v] = input[i].split(" ");
  W[i] = +w;
  V[i] = +v;
}
for (let i = 1; i <= len; i++) {
  for (let j = max; j - W[i] >= 0; j--) {
    dp[j] = Math.max(dp[j], dp[j - W[i]] + V[i]);
  }
}
console.log(dp[max]);
```